## 第四章：类和接口

### 一. 使类和成员的可访问性最小
1. 信息隐藏或者封装是软件设计的基本原则之一：解耦

2. java访问权限
```java
1. private: “私有的”,被修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。

2. default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。

3. protected: 一般称之为“受保护的访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。

4. public：“公共的”, 被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。
```

3. 一般子类的访问权限要大于等于超类的访问权限（里氏替换原则）

4. 共有类的实例域决不能是共有的，即使是final修饰，也有可能指向可变对象的引用，而且这样做通常是线程不安全的。但是看中台代码，在工具类中通过
static暴露了一些常量（书写格式：字母大写，用下划线隔开），一般采用private修饰（隐藏实现细节，比如可以在赋值前对属性进行检查，而且在
类的实现中，设计数组这种引用类型成员操作时一定要特别注意不要传递引用）
https://juejin.im/post/5d9b25865188250969774e64

5. 类的实现中，设计数组这种引用类型成员操作时一定要特别注意不要传递引用。也就是不要将引用传递到set方法，不要将引用返回给get方法，如果
要这样做，要事先拷贝一份，可以使用unmodifiableXXX

6. 综上：应该尽可能的降低元素的可访问权限，在设计时应该防止把杂乱的类，接口，成员变量变成API的一部分。
除了共有静态final域的特殊情况之外（此时他们充当常量），共有类都不应该包含共有域，并且要确保共有静态final
域不引用可变对象

### 二. 要在共有类而非共有域中使用访问方法？

### 三. 使可变性最小化
1. java中的不可变类有：String,基本类型封装类,BigDecimal,BigInteger

2. 不可变对象（大部分成员被final修饰，也可以限制set方法的使用）优点：比较简单，线程安全，可被共享。在实现时一般通过保护性拷贝技术
```java
// Immutable complex number class (Pages 81-82)
public final class Complex {
    private final double re;
    private final double im;

    public static final Complex ZERO = new Complex(0, 0);
    public static final Complex ONE  = new Complex(1, 0);
    public static final Complex I    = new Complex(0, 1);

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart()      { return re; }
    public double imaginaryPart() { return im; }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    // Static factory, used in conjunction with private constructor (Page 85)
    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im,
                re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
                (im * c.re - re * c.im) / tmp);
    }

    @Override public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Complex))
            return false;
        Complex c = (Complex) o;

        // See page 47 to find out why we use compare instead of ==
        return Double.compare(c.re, re) == 0
                && Double.compare(c.im, im) == 0;
    }
    @Override public int hashCode() {
        return 31 * Double.hashCode(re) + Double.hashCode(im);
    }

    @Override public String toString() {
        return "(" + re + " + " + im + "i)";
    }
}
```

3. 静态变量（常驻内存）并不是说其就不能改变值，不能改变值的量叫常量。 其拥有的值是可变的 ，而且它会保持最新的值。
说其静态，是因为它不会随着函数的调用和退出而发生变化。即上次调用函数的时候，如果我们给静态变量赋予某个值的话，
下次函数调用时，这个值保持不变。
   
4. final修饰变量不可变，修饰类不可继承，修饰方法不可被子类重写。
static修饰变量常驻内存，可修改；修饰类一般是静态内部类。
修饰方法：一般可以通过对象名.方法名调用。否则通过实例.方法名调用。同时对静态成员的访问方法不同，静态方法只允许访问静态资源https://www.cnblogs.com/dolphin0520/p/3736238.html